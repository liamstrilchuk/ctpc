```javascript
function shortestTitleLength(input) {
    const [K, Rn, Pn, Sn, P, S, ...lines] = input.split('\n').filter(Boolean);
    const [targetScore, rootCount, prefixCount, suffixCount, maxPrefixes, maxSuffixes] = [K, Rn, Pn, Sn, P, S].map(Number);

    const roots = [];
    const prefixes = [];
    const suffixes = [];

    let index = 0;
    for (let i = 0; i < rootCount; i++) {
        const [word, score] = lines[index++].split(' ');
        roots.push({ word, score: +score });
    }

    for (let i = 0; i < prefixCount; i++) {
        const [word, score] = lines[index++].split(' ');
        prefixes.push({ word, score: +score });
    }

    for (let i = 0; i < suffixCount; i++) {
        const [word, score] = lines[index++].split(' ');
        suffixes.push({ word, score: +score });
    }

    let minLength = Infinity;

    function findCombinations(prefixComb, suffixComb, rootIndex, currentScore, currentLength) {
        if (currentScore === targetScore) {
            minLength = Math.min(minLength, currentLength);
            return;
        }
        if (rootIndex >= roots.length) return;

        const root = roots[rootIndex];

        for (let p = 0; p <= maxPrefixes && p <= prefixComb.length; p++) {
            const prefixScore = prefixComb.slice(0, p).reduce((acc, x) => acc + x.score, 0);
            const prefixLength = prefixComb.slice(0, p).reduce((acc, x) => acc + x.word.length, 0);

            for (let s = 0; s <= maxSuffixes && s <= suffixComb.length; s++) {
                const suffixScore = suffixComb.slice(0, s).reduce((acc, x) => acc + x.score, 0);
                const suffixLength = suffixComb.slice(0, s).reduce((acc, x) => acc + x.word.length, 0);

                const totalScore = root.score + prefixScore + suffixScore;
                const totalLength = root.word.length + prefixLength + suffixLength;

                if (totalScore === targetScore) {
                    minLength = Math.min(minLength, totalLength);
                }
            }
        }

        findCombinations(prefixComb, suffixComb, rootIndex + 1, currentScore, currentLength);
    }

    function generateCombinations(arr, max, callback) {
        const n = arr.length;
        const result = [];

        function dfs(start, path) {
            if (path.length <= max) {
                callback(path);
            }
            for (let i = start; i < n; i++) {
                path.push(arr[i]);
                dfs(i + 1, path);
                path.pop();
            }
        }

        dfs(0, result);
    }

    generateCombinations(prefixes, maxPrefixes, prefixComb => {
        generateCombinations(suffixes, maxSuffixes, suffixComb => {
            findCombinations(prefixComb, suffixComb, 0, 0, 0);
        });
    });

    return minLength;
}
```